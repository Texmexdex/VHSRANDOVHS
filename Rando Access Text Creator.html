<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HYPERION VHS Glitch Core - Config v3</title> 
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&family=Orbitron:wght@400;700&family=Audiowide&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <style>
        /* --- START OF COMBINED CSS --- */
        :root {
            /* Font & Text */
            --main-font-family: 'VT323', monospace; --font-size-vw: 12vw; --font-stretch: 100%;
            --title-color: #00FF00; --text-skew-x: 0deg; --text-skew-y: 0deg; --text-bloom-blur: 0px; --text-bloom-brightness: 1;
            /* Shadows & Glow */
            --title-glow-color: rgba(0, 255, 0, 0.6); --text-shadow-offset-x: 3px; --text-shadow-offset-y: 3px; --text-shadow-blur: 0px; --text-shadow-color: rgba(0, 0, 0, 0.7); --chromatic-aberration-opacity: 0.3;
            /* Base Animations */
            --pulse-duration: 2.5s; --glitch-base-duration: 3s; --glitch-intense-duration: 0.35s;
            /* CRT & Overlay */
            --crt-scale: 1.0; --crt-perspective: 1000px; --crt-lens-effect-opacity: 0; --crt-lens-shine-opacity: 0.08; --crt-lens-edge-darken-opacity: 0.3; --scanline-opacity: 0.7; --scanline-thickness: 3px; --scanline-color1: rgba(18, 16, 16, 0); --scanline-color2: rgba(0, 0, 0, 0.25); --text-pixelation: auto; 
            /* Simulated Audio Pulse */
            --simulated-beat-scale: 1.02; --simulated-beat-true-scale: 1.02; --simulated-beat-opacity: 0.9; --simulated-beat-duration: 0.5s;
        }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; position: relative; font-family: var(--main-font-family, 'VT323', monospace); color: #eee; }
        #simulationCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; display: block; }
        .content-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; overflow: hidden; perspective: var(--crt-perspective); }
        .content { z-index: 2; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; pointer-events: none; transform-origin: center center; transform: scale(var(--crt-scale)); transition: transform 0.1s ease-out; }
        .content-wrapper::before { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: radial-gradient(ellipse at center, rgba(255,255,255,var(--crt-lens-shine-opacity)) 0%, rgba(255,255,255,var(--crt-lens-shine-opacity)) 30%, rgba(0,0,0, var(--crt-lens-edge-darken-opacity)) 70%, rgba(0,0,0, var(--crt-lens-edge-darken-opacity)) 100% ); z-index: 3; pointer-events: none; border-radius: 50%; opacity: var(--crt-lens-effect-opacity); mix-blend-mode: overlay; transition: opacity 0.2s; }
        .title { pointer-events: auto; display: block; text-align: center; font-family: var(--main-font-family); font-size: clamp(30px, var(--font-size-vw), 200px); font-stretch: var(--font-stretch); font-weight: bold; color: var(--title-color); text-transform: uppercase; text-shadow: var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color), 0 0 8px var(--title-glow-color), 0 0 15px color-mix(in srgb, var(--title-glow-color) 70%, transparent), 1px 1px 1px rgba(0, 255, 255, var(--chromatic-aberration-opacity)), -1px -1px 1px rgba(255, 0, 255, var(--chromatic-aberration-opacity)); animation: pulse var(--pulse-duration) ease-in-out 0s infinite alternate, glitch-base var(--glitch-base-duration) steps(6, end) 0s infinite; transform-origin: center center; user-select: none; transform: skewX(var(--text-skew-x)) skewY(var(--text-skew-y)); transition: transform 0.05s linear, color 0.3s, text-shadow 0.3s, filter 0.2s; image-rendering: var(--text-pixelation); filter: blur(var(--text-bloom-blur)) brightness(var(--text-bloom-brightness)); }
        .title.simulated-audio-pulse { animation: simulated-pulse-beat var(--simulated-beat-duration) ease-in-out infinite alternate; }
        @keyframes simulated-pulse-beat { from { opacity: 1; } to { transform: scale(var(--simulated-beat-true-scale)); opacity: var(--simulated-beat-opacity); } }
        .title span { display: block; line-height: 0.9; margin-bottom: -0.1em; }
        body::after { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(var(--scanline-color1) 50%, var(--scanline-color2) 50%); background-size: 100% var(--scanline-thickness); z-index: 1; pointer-events: none; animation: scanline-flicker 0.07s infinite alternate; opacity: var(--scanline-opacity); }
        @keyframes scanline-flicker { from { filter: brightness(0.95); } to { filter: brightness(1.05); } }
        #controlsPanel { position: fixed; bottom: 10px; left: 10px; background-color: rgba(10, 10, 10, 0.92); padding: 15px; border-radius: 8px; border: 1px solid #0f0; z-index: 100; font-family: 'VT323', monospace; color: #0f0; box-shadow: 0 0 20px rgba(0, 255, 0, 0.4); max-width: 390px; max-height: calc(100vh - 60px); overflow-y: auto; transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; }
        #controlsPanel.hidden { transform: translateX(-110%); opacity: 0; pointer-events: none; }
        #controlsPanel h3, #controlsPanel h4 { margin-top: 0; margin-bottom: 10px; font-size: 1.3em; border-bottom: 1px solid #0f0; padding-bottom: 8px; text-shadow: 0 0 5px #0f0; }
        #controlsPanel h4 { font-size: 1.1em; margin-top: 15px; border-bottom-style: dashed; }
        #controlsPanel label { display: block; margin-top: 12px; margin-bottom: 4px; font-size: 1em; }
        #controlsPanel input, #controlsPanel select, #controlsPanel textarea { width: calc(100% - 12px); padding: 6px; margin-bottom: 10px; background-color: #1a1a1a; border: 1px solid #0a0; color: #0f0; font-family: 'VT323', monospace; font-size: 1em; box-sizing: border-box;}
        #controlsPanel input[type="color"] { padding: 2px; height: 35px; cursor: pointer; }
        #controlsPanel input[type="checkbox"] { width: auto; margin-right: 5px; vertical-align: middle; cursor: pointer; }
        #controlsPanel label[for*="checkbox"] { display: inline; cursor: pointer; }
        #controlsPanel textarea { min-height: 60px; resize: vertical; }
        #controlsPanel .control-group { margin-bottom: 15px; border-bottom: 1px dashed #050; padding-bottom: 10px; }
        #controlsPanel .control-group:last-child { margin-bottom: 0; border-bottom: none; padding-bottom: 0; }
        #controlsPanel .value-display { display: inline-block; margin-left: 10px; color: #fff; background-color: #333; padding: 2px 5px; border-radius: 3px; font-size: 0.9em; }
        #controlsPanel .button-group { margin-top: 20px; display: flex; flex-wrap: wrap; justify-content: space-between; border-top: 1px dashed #050; padding-top: 15px; gap: 10px; }
        #controlsPanel .button-group button { width: 48%; padding: 8px 5px; font-size: 0.9em; cursor: pointer; background-color: #080; border: 1px solid #0f0; color: #000; transition: background-color 0.2s; border-radius: 4px; }
        #controlsPanel .button-group button:hover { background-color: #0c0; }
        #controlsPanel .button-group button#loadSettingsBtn { background-color: #505; border-color: #a0a; color: #eee; }
        #controlsPanel .button-group button#loadSettingsBtn:hover { background-color: #808; }
        #controlsPanel .button-group button#saveStandaloneBtn { background-color: #2a7f8c; border-color: #61afef; color: #eee; width: 100%; } 
        #controlsPanel .button-group button#saveStandaloneBtn:hover { background-color: #3a9fbc; }
        #toggleControlsBtn { position: fixed; bottom: 10px; left: 10px; z-index: 101; background-color: #0a0; color: #000; border: 1px solid #0f0; padding: 8px 12px; font-family: 'VT323', monospace; font-size: 1em; cursor: pointer; border-radius: 5px; box-shadow: 0 0 10px rgba(0, 255, 0, 0.5); transition: background-color 0.2s, left 0.3s ease-in-out; }
        #toggleControlsBtn:hover { background-color: #0f0; }
        @keyframes glitch-base { 0%, 100% { transform: translate(0, 0); text-shadow: 1px 1px 0 rgba(0, 255, 255, 0.5), -1px -1px 0 rgba(255, 0, 255, 0.5), var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 20% { transform: translate(-1px, 1px); } 40% { transform: translate(1px, -1px); text-shadow: -1px 1px 0 rgba(0, 255, 255, 0.5), 1px -1px 0 rgba(255, 0, 255, 0.5), var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 60% { transform: translate(0, 0); text-shadow: 1px 1px 0 rgba(0, 255, 255, 0.5), -1px -1px 0 rgba(255, 0, 255, 0.5), var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 80% { transform: translate(1px, 1px); } }
        .title-glitch-intense { animation: pulse var(--pulse-duration) ease-in-out 0s infinite alternate, glitch-intense var(--glitch-intense-duration) steps(4, end) 0s infinite; }
        @keyframes glitch-intense { 0% { transform: translate(6px, -4px) skewX(calc(-12deg * var(--master-intensity, 1) * 0.7)) skewY(calc(1deg * var(--master-intensity, 1))); text-shadow: 6px 3px 0 #00ffff, -6px -3px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 25% { transform: translate(-5px, 3px) skewX(calc(20deg * var(--master-intensity, 1))) skewY(calc(-1.5deg * var(--master-intensity, 1))); text-shadow: -4px 4px 0 #00ffff, 4px -4px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 50% { transform: translate(4px, -2px) skewX(calc(-15deg * var(--master-intensity, 1))) skewY(calc(2deg * var(--master-intensity, 1))); text-shadow: 5px -3px 0 #00ffff, -5px 3px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 75% { transform: translate(-3px, 5px) skewX(calc(25deg * var(--master-intensity, 1) * 0.8)) skewY(calc(-2.5deg * var(--master-intensity, 1))); text-shadow: -3px -3px 0 #00ffff, 3px 3px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 100% { transform: translate(5px, -3px) skewX(calc(-18deg * var(--master-intensity, 1))) skewY(calc(1.5deg * var(--master-intensity, 1))); text-shadow: 4px 2px 0 #00ffff, -4px -2px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } }
        @keyframes pulse { 0% { opacity: 1; } 50% { transform: scale(1.04); opacity: 0.85; } 100% { opacity: 1; } }
        /* --- END OF COMBINED CSS --- */
    </style>
</head>
<body>
    <canvas id="simulationCanvas"></canvas>
    <div class="content-wrapper">
        <div class="content"><h1 class="title" id="mainTitle"></h1></div>
    </div>
    <button id="toggleControlsBtn">Hide Controls</button>

    <!-- Controls Panel -->
    <div id="controlsPanel">
        <h3>HYPERION DIAGNOSTICS</h3>
        <div class="control-group"> <label for="masterIntensity">Master Effect Intensity:</label> <input type="range" id="masterIntensity" min="0.1" max="3.0" step="0.1" value="1.0"> <span class="value-display" id="masterIntensityValue">1.0x</span> </div>
        <div class="control-group"> <label for="colorPalette">Color Palette Preset:</label> <select id="colorPalette"> <option value="custom">Custom</option> <option value="classic_red">Classic Red</option> <option value="matrix_green">Matrix Green</option> <option value="arcade_blue">Arcade Blue</option> <option value="amber_mono">Amber Monochrome</option> <option value="grayscale">Grayscale</option> </select> </div>
        <h4>Text Content & Appearance:</h4>
        <div class="control-group"><label for="textInput">Display Text (New line = new word):</label><textarea id="textInput" rows="3">HYPERION\nCORE\nCONFIG</textarea></div>
        <div class="control-group"><label for="fontFamily">Font Family:</label><select id="fontFamily"><option value="'VT323', monospace">VT323</option><option value="'Press Start 2P', monospace">Press Start 2P</option><option value="'Share Tech Mono', monospace">Share Tech Mono</option><option value="'Orbitron', sans-serif">Orbitron</option><option value="'Audiowide', sans-serif">Audiowide</option><option value="monospace">Monospace</option><option value="sans-serif">Sans-Serif</option></select></div>
        <div class="control-group"><label for="fontSize">Font Size (vw):</label><input type="range" id="fontSize" min="4" max="20" step="0.5" value="12"><span class="value-display" id="fontSizeValue">12vw</span></div>
        <div class="control-group"><label for="fontStretch">Font Width (Stretch %):</label><input type="range" id="fontStretch" min="50" max="150" step="5" value="100"><span class="value-display" id="fontStretchValue">100%</span><small style="display:block; color:#090; font-size:0.8em;">Note: Effect varies by font.</small></div>
        <div class="control-group"><label for="textColor">Text Color:</label><input type="color" id="textColor" value="#00FF00"></div>
        <div class="control-group"><label for="textSkewX">Text Skew X (deg):</label><input type="range" id="textSkewX" min="-15" max="15" step="1" value="0"><span class="value-display" id="textSkewXValue">0deg</span></div>
        <div class="control-group"><label for="textSkewY">Text Skew Y (deg):</label><input type="range" id="textSkewY" min="-10" max="10" step="1" value="0"><span class="value-display" id="textSkewYValue">0deg</span></div>
        <div class="control-group"><label for="textBloomBlur">Text Bloom Blur (px):</label><input type="range" id="textBloomBlur" min="0" max="10" step="0.2" value="0"><span class="value-display" id="textBloomBlurValue">0px</span></div>
        <div class="control-group"><label for="textBloomBrightness">Text Bloom Brightness:</label><input type="range" id="textBloomBrightness" min="0.5" max="2.5" step="0.05" value="1.0"><span class="value-display" id="textBloomBrightnessValue">1.0</span></div>
        <div class="control-group"><label for="shadowOffsetX">Shadow X:</label><input type="range" id="shadowOffsetX" min="-10" max="10" step="1" value="3"><span class="value-display" id="shadowOffsetXValue">3px</span></div>
        <div class="control-group"><label for="shadowOffsetY">Shadow Y:</label><input type="range" id="shadowOffsetY" min="-10" max="10" step="1" value="3"><span class="value-display" id="shadowOffsetYValue">3px</span></div>
        <div class="control-group"><label for="chromaticAberrationIntensity">Chromatic Aberration:</label><input type="range" id="chromaticAberrationIntensity" min="0" max="1" step="0.05" value="0.3"><span class="value-display" id="chromaticAberrationIntensityValue">0.3</span></div>
        <div class="control-group"> <input type="checkbox" id="textPixelationToggle"> <label for="textPixelationToggle" style="font-size:1em; margin-left:5px;">Enable Text Pixelation (CSS)</label> </div>
        <h4>Animation & Glitch Effects:</h4>
        <div class="control-group"> <input type="checkbox" id="enableTextColorFlash"><label for="enableTextColorFlash" style="font-size:1em; margin-left:5px;">Text Color Flash Glitch</label><br> <label for="textColorFlashProbability" style="margin-left:25px;">Probability:</label><input type="range" id="textColorFlashProbability" min="0" max="0.1" step="0.005" value="0.01"><span class="value-display" id="textColorFlashProbabilityValue">0.01</span></div>
        <div class="control-group"> <input type="checkbox" id="enableCharSwap"><label for="enableCharSwap" style="font-size:1em;margin-left:5px;">Character Swap Glitch</label><br> <label for="charSwapProbability" style="margin-left:25px;">Probability:</label><input type="range" id="charSwapProbability" min="0" max="0.1" step="0.001" value="0.01"><span class="value-display" id="charSwapProbabilityValue">0.01</span><br> <label for="charSwapDensity" style="margin-left:25px;">Swap Density (%):</label><input type="range" id="charSwapDensity" min="1" max="50" step="1" value="10"><span class="value-display" id="charSwapDensityValue">10%</span></div>
        <div class="control-group"> <input type="checkbox" id="enableBadTracking" checked><label for="enableBadTracking" style="font-size:1em;margin-left:5px;">Bad Tracking Jitter</label><br> <label for="badTrackingProbability" style="margin-left:25px;">Probability:</label><input type="range" id="badTrackingProbability" min="0" max="0.1" step="0.005" value="0.01"><span class="value-display" id="badTrackingProbabilityValue">0.01</span></div>
        <div class="control-group"> <input type="checkbox" id="simulatedAudioPulseToggle"> <label for="simulatedAudioPulseToggle" style="font-size:1em; margin-left:5px;">Simulated Audio Pulse</label><br> <input type="checkbox" id="disableBeatScaleToggle" style="margin-left:25px;"> <label for="disableBeatScaleToggle" style="font-size:0.9em; margin-left:5px;">Disable Beat Scale (Opacity Only)</label><br> <label for="simulatedBeatScale" style="margin-left:25px;">Beat Scale:</label> <input type="range" id="simulatedBeatScale" min="1.0" max="1.1" step="0.005" value="1.02"> <span class="value-display" id="simulatedBeatScaleValue">1.02</span><br> <label for="simulatedBeatOpacity" style="margin-left:25px;">Beat Opacity:</label> <input type="range" id="simulatedBeatOpacity" min="0.5" max="1.0" step="0.05" value="0.9"> <span class="value-display" id="simulatedBeatOpacityValue">0.9</span><br> <label for="simulatedBeatDuration" style="margin-left:25px;">Beat Duration (s):</label> <input type="range" id="simulatedBeatDuration" min="0.1" max="2.0" step="0.05" value="0.5"> <span class="value-display" id="simulatedBeatDurationValue">0.5s</span></div>
        <div class="control-group"><label for="baseGlitchSpeed">Base Glitch Speed (s):</label><input type="range" id="baseGlitchSpeed" min="0.5" max="10" step="0.1" value="3.0"><span class="value-display" id="baseGlitchSpeedValue">3.0s</span></div>
        <div class="control-group"><label for="intenseGlitchSpeed">Intense Glitch Speed (s):</label><input type="range" id="intenseGlitchSpeed" min="0.1" max="1.0" step="0.05" value="0.35"><span class="value-display" id="intenseGlitchSpeedValue">0.35s</span></div>
        <div class="control-group"><label for="pulseSpeed">Base Pulse Speed (s):</label><input type="range" id="pulseSpeed" min="0.5" max="5.0" step="0.1" value="2.5"><span class="value-display" id="pulseSpeedValue">2.5s</span></div>
        <h4>CRT & Canvas Effects:</h4>
        <div class="control-group"> <input type="checkbox" id="enableChannelSwitchBurst"><label for="enableChannelSwitchBurst" style="font-size:1em; margin-left:5px;">Channel Switch Static Burst</label><br> <label for="channelSwitchBurstProbability" style="margin-left:25px;">Probability:</label><input type="range" id="channelSwitchBurstProbability" min="0" max="0.02" step="0.001" value="0.002"><span class="value-display" id="channelSwitchBurstProbabilityValue">0.002</span></div>
        <div class="control-group"> <label for="vhsEffectType">Canvas Tracking Lines/Blocks:</label><select id="vhsEffectType"><option value="none">None</option><option value="subtle">Subtle</option><option value="moderate" selected>Moderate</option><option value="heavy">Heavy</option></select><br> <input type="checkbox" id="enableIntenseTextGlitchOnSignal" checked style="margin-left:25px;"> <label for="enableIntenseTextGlitchOnSignal" style="font-size:0.9em; margin-left:5px;">Trigger Intense Text Glitch on Signal</label></div>
        <div class="control-group"><label for="crtScale">CRT Fisheye Scale:</label><input type="range" id="crtScale" min="0.8" max="1.2" step="0.01" value="1.0"><span class="value-display" id="crtScaleValue">1.0</span></div>
        <div class="control-group"> <label for="crtLensEffectOpacity">CRT Lens Effect Opacity:</label> <input type="range" id="crtLensEffectOpacity" min="0" max="1" step="0.05" value="0"> <span class="value-display" id="crtLensEffectOpacityValue">0</span> </div>
        <div class="control-group"> <label for="crtLensShineOpacity">CRT Lens Shine Opacity:</label> <input type="range" id="crtLensShineOpacity" min="0" max="0.3" step="0.01" value="0.08"> <span class="value-display" id="crtLensShineOpacityValue">0.08</span> </div>
        <div class="control-group"> <label for="crtLensEdgeDarkenOpacity">CRT Lens Edge Darken:</label> <input type="range" id="crtLensEdgeDarkenOpacity" min="0" max="0.8" step="0.02" value="0.3"> <span class="value-display" id="crtLensEdgeDarkenOpacityValue">0.3</span> </div>
        <div class="control-group"> <input type="checkbox" id="enableHumBar" checked> <label for="enableHumBar" style="font-size:1em; margin-left:5px;">Enable Rolling Hum Bar</label><br> <label for="humBarOpacity" style="margin-left:25px;">Opacity:</label> <input type="range" id="humBarOpacity" min="0" max="0.3" step="0.01" value="0.08"> <span class="value-display" id="humBarOpacityValue">0.08</span><br> <label for="humBarSpeed" style="margin-left:25px;">Speed:</label> <input type="range" id="humBarSpeed" min="1" max="20" step="1" value="5"> <span class="value-display" id="humBarSpeedValue">5</span> </div>
        <div class="control-group"><label for="scanlineThickness">Scanline Thickness (px):</label><input type="range" id="scanlineThickness" min="1" max="10" step="1" value="3"><span class="value-display" id="scanlineThicknessValue">3px</span></div>
        <div class="control-group"><label for="staticIntensity">BG Static Intensity:</label><input type="range" id="staticIntensity" min="0" max="1" step="0.05" value="0.25"><span class="value-display" id="staticIntensityValue">0.25</span></div>
        <div class="control-group"><label for="noiseTintIntensity">BG Static Color Tint:</label><input type="range" id="noiseTintIntensity" min="0" max="0.3" step="0.01" value="0.05"><span class="value-display" id="noiseTintIntensityValue">0.05</span></div>
        <div class="control-group"><label for="scanlineOpacity">Scanline Opacity:</label><input type="range" id="scanlineOpacity" min="0" max="1" step="0.05" value="0.7"><span class="value-display" id="scanlineOpacityValue">0.7</span></div>
        
        <!-- Buttons -->
        <div class="button-group"> 
            <button id="saveSettingsBtn">Save Settings</button> 
            <button id="loadSettingsBtn">Load Settings</button> 
            <button id="saveStandaloneBtn">Save Standalone HTML</button> 
        </div>

    </div> <!-- End Controls Panel -->

    <!-- Embedded JavaScript -->
    <script>
        // --- START OF EMBEDDED JAVASCRIPT ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- ELEMENT GETTERS ---
            const canvas = document.getElementById('simulationCanvas'); const titleElement = document.getElementById('mainTitle'); const contentElement = document.querySelector('.content'); const rootStyle = document.documentElement.style; const ctx = canvas.getContext('2d', { alpha: false }); const controlsPanel = document.getElementById('controlsPanel'); const toggleControlsBtn = document.getElementById('toggleControlsBtn'); const masterIntensityElement = document.getElementById('masterIntensity'); const masterIntensityValueElement = document.getElementById('masterIntensityValue'); const colorPaletteElement = document.getElementById('colorPalette'); const textInputElement = document.getElementById('textInput'); const fontFamilyElement = document.getElementById('fontFamily'); const fontSizeElement = document.getElementById('fontSize'); const fontSizeValueElement = document.getElementById('fontSizeValue'); const fontStretchElement = document.getElementById('fontStretch'); const fontStretchValueElement = document.getElementById('fontStretchValue'); const textColorElement = document.getElementById('textColor'); const textSkewXElement = document.getElementById('textSkewX'); const textSkewXValueElement = document.getElementById('textSkewXValue'); const textSkewYElement = document.getElementById('textSkewY'); const textSkewYValueElement = document.getElementById('textSkewYValue'); const textBloomBlurElement = document.getElementById('textBloomBlur'); const textBloomBlurValueElement = document.getElementById('textBloomBlurValue'); const textBloomBrightnessElement = document.getElementById('textBloomBrightness'); const textBloomBrightnessValueElement = document.getElementById('textBloomBrightnessValue'); const shadowOffsetXElement = document.getElementById('shadowOffsetX'); const shadowOffsetXValueElement = document.getElementById('shadowOffsetXValue'); const shadowOffsetYElement = document.getElementById('shadowOffsetY'); const shadowOffsetYValueElement = document.getElementById('shadowOffsetYValue'); const chromaticAberrationIntensityElement = document.getElementById('chromaticAberrationIntensity'); const chromaticAberrationIntensityValueElement = document.getElementById('chromaticAberrationIntensityValue'); const textPixelationToggleElement = document.getElementById('textPixelationToggle'); const enableBadTrackingElement = document.getElementById('enableBadTracking'); const badTrackingProbabilityElement = document.getElementById('badTrackingProbability'); const badTrackingProbabilityValueElement = document.getElementById('badTrackingProbabilityValue'); const enableCharSwapElement = document.getElementById('enableCharSwap'); const charSwapProbabilityElement = document.getElementById('charSwapProbability'); const charSwapProbabilityValueElement = document.getElementById('charSwapProbabilityValue'); const charSwapDensityElement = document.getElementById('charSwapDensity'); const charSwapDensityValueElement = document.getElementById('charSwapDensityValue'); const simulatedAudioPulseToggleElement = document.getElementById('simulatedAudioPulseToggle'); const disableBeatScaleToggleElement = document.getElementById('disableBeatScaleToggle'); const simulatedBeatScaleElement = document.getElementById('simulatedBeatScale'); const simulatedBeatScaleValueElement = document.getElementById('simulatedBeatScaleValue'); const simulatedBeatOpacityElement = document.getElementById('simulatedBeatOpacity'); const simulatedBeatOpacityValueElement = document.getElementById('simulatedBeatOpacityValue'); const simulatedBeatDurationElement = document.getElementById('simulatedBeatDuration'); const simulatedBeatDurationValueElement = document.getElementById('simulatedBeatDurationValue'); const enableTextColorFlashElement = document.getElementById('enableTextColorFlash'); const textColorFlashProbabilityElement = document.getElementById('textColorFlashProbability'); const textColorFlashProbabilityValueElement = document.getElementById('textColorFlashProbabilityValue'); const baseGlitchSpeedElement = document.getElementById('baseGlitchSpeed'); const baseGlitchSpeedValueElement = document.getElementById('baseGlitchSpeedValue'); const intenseGlitchSpeedElement = document.getElementById('intenseGlitchSpeed'); const intenseGlitchSpeedValueElement = document.getElementById('intenseGlitchSpeedValue'); const pulseSpeedElement = document.getElementById('pulseSpeed'); const pulseSpeedValueElement = document.getElementById('pulseSpeedValue'); const crtScaleElement = document.getElementById('crtScale'); const crtScaleValueElement = document.getElementById('crtScaleValue'); const crtLensEffectOpacityElement = document.getElementById('crtLensEffectOpacity'); const crtLensEffectOpacityValueElement = document.getElementById('crtLensEffectOpacityValue'); const crtLensShineOpacityElement = document.getElementById('crtLensShineOpacity'); const crtLensShineOpacityValueElement = document.getElementById('crtLensShineOpacityValue'); const crtLensEdgeDarkenOpacityElement = document.getElementById('crtLensEdgeDarkenOpacity'); const crtLensEdgeDarkenOpacityValueElement = document.getElementById('crtLensEdgeDarkenOpacityValue'); const enableHumBarElement = document.getElementById('enableHumBar'); const humBarOpacityElement = document.getElementById('humBarOpacity'); const humBarOpacityValueElement = document.getElementById('humBarOpacityValue'); const humBarSpeedElement = document.getElementById('humBarSpeed'); const humBarSpeedValueElement = document.getElementById('humBarSpeedValue'); const enableChannelSwitchBurstElement = document.getElementById('enableChannelSwitchBurst'); const channelSwitchBurstProbabilityElement = document.getElementById('channelSwitchBurstProbability'); const channelSwitchBurstProbabilityValueElement = document.getElementById('channelSwitchBurstProbabilityValue'); const enableIntenseTextGlitchOnSignalElement = document.getElementById('enableIntenseTextGlitchOnSignal'); const scanlineThicknessElement = document.getElementById('scanlineThickness'); const scanlineThicknessValueElement = document.getElementById('scanlineThicknessValue'); const staticIntensityElement = document.getElementById('staticIntensity'); const staticIntensityValueElement = document.getElementById('staticIntensityValue'); const noiseTintIntensityElement = document.getElementById('noiseTintIntensity'); const noiseTintIntensityValueElement = document.getElementById('noiseTintIntensityValue'); const vhsEffectTypeElement = document.getElementById('vhsEffectType'); const scanlineOpacityElement = document.getElementById('scanlineOpacity'); const scanlineOpacityValueElement = document.getElementById('scanlineOpacityValue'); const saveSettingsBtn = document.getElementById('saveSettingsBtn'); const loadSettingsBtn = document.getElementById('loadSettingsBtn'); 
            const saveStandaloneBtn = document.getElementById('saveStandaloneBtn'); 

            // --- JS-side Parameters & State ---
            const colorPalettes = { custom: {}, classic_red: { textColor: '#FF0000', glowFactor: 0.6, shadowColor: 'rgba(0,0,0,0.7)' }, matrix_green: { textColor: '#00FF41', glowFactor: 0.7, shadowColor: 'rgba(0,20,0,0.7)' }, arcade_blue: { textColor: '#00BFFF', glowFactor: 0.6, shadowColor: 'rgba(0,0,30,0.7)' }, amber_mono: { textColor: '#FFBF00', glowFactor: 0.5, shadowColor: 'rgba(40,20,0,0.6)' }, grayscale: { textColor: '#CCCCCC', glowFactor: 0.4, shadowColor: 'rgba(0,0,0,0.7)' } };
            let originalTitleColor = '#00FF00'; 
            let masterIntensity = 1.0;
            let baseNoiseIntensity = 0.25, effectiveNoiseIntensity = 0.25;
            let baseNoiseColorTintIntensity = 0.05, effectiveNoiseColorTintIntensity = 0.05;
            let baseTrackingLineProbability = 0.09, effectiveTrackingLineProbability = 0.09;
            let baseBlockDistortionProbability = 0.02, effectiveBlockDistortionProbability = 0.02;
            let baseChromaticAberrationOpacity = 0.3, effectiveChromaticAberrationOpacity = 0.3;
            let trackingLineMaxHeight = 12, trackingLineMinHeight = 1, trackingLineDistortion = 20, trackingLineMinIntensity = 0.1, trackingLineMaxIntensity = 0.8;
            let blockDistortionMaxHeight = 30, blockDistortionMinHeight = 5, blockDistortionIntensity = 0.6;
            let badTrackingEnabled = true, badTrackingBaseProbability = 0.01, badTrackingJumpTimeout = null, currentBadTrackingYOffset = 0;
            let charSwapEnabled = false, charSwapBaseProbability = 0.01, originalTextSpans = [];
            let charSwapDensity = 0.1; 
            let textColorFlashEnabled = false, textColorFlashBaseProbability = 0.01, textColorFlashTimeout = null; 
            let textBloomBlur = 0; 
            let textBloomBrightness = 1; 
            let humBarEnabled = true, humBarY = 0, humBarHeight = 50, humBarBaseOpacity = 0.08, humBarBaseSpeed = 5;
            let simulatedAudioPulseEnabled = false;
            let beatScaleDisabled = false; 
            let channelSwitchBurstEnabled = false, channelSwitchBurstBaseProbability = 0.002, channelSwitchBurstTimeout = null; 
            let triggerIntenseTextGlitchOnSignal = true; 
            let w, h, noiseImageData, intenseGlitchTimeout = null;
            let intenseGlitchDurationMs = 150; 

            // --- Canvas Setup & Resize ---
            function resizeCanvas() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; if (w > 0 && h > 0) noiseImageData = ctx.createImageData(w, h); }
            let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(resizeCanvas, 150); });
            
            // --- Drawing Functions ---
            function drawNoise(overrideIntensity, overrideColor) { if (!noiseImageData || (overrideIntensity === undefined && effectiveNoiseIntensity === 0)) return; const intensityToUse = overrideIntensity !== undefined ? overrideIntensity : effectiveNoiseIntensity; const pixels = noiseImageData.data; const len = pixels.length; for (let i = 0; i < len; i += 4) { const noiseValue = Math.random() * 255 * intensityToUse; if (overrideColor) { pixels[i] = Math.max(0, Math.min(255, noiseValue * overrideColor[0])); pixels[i + 1] = Math.max(0, Math.min(255, noiseValue * overrideColor[1])); pixels[i + 2] = Math.max(0, Math.min(255, noiseValue * overrideColor[2])); } else { const rTint = (Math.random() - 0.5) * 255 * effectiveNoiseColorTintIntensity; const bTint = (Math.random() - 0.5) * 255 * effectiveNoiseColorTintIntensity; pixels[i] = Math.max(0, Math.min(255, noiseValue + rTint)); pixels[i + 1] = Math.max(0, Math.min(255, noiseValue)); pixels[i + 2] = Math.max(0, Math.min(255, noiseValue + bTint)); } pixels[i + 3] = 255; } ctx.putImageData(noiseImageData, 0, 0); }
            function drawTrackingLines() { if (!titleElement) return; let intenseGlitchSignalDetected = false; if (effectiveTrackingLineProbability > 0 && Math.random() < effectiveTrackingLineProbability) { const lineY = Math.random() * h; const lineHeight = Math.random() * (trackingLineMaxHeight - trackingLineMinHeight) + trackingLineMinHeight; const lineOpacity = Math.random() * (trackingLineMaxIntensity - trackingLineMinIntensity) + trackingLineMinIntensity; const lineDistortionVal = (Math.random() - 0.5) * 2 * trackingLineDistortion; ctx.fillStyle = `rgba(255, 255, 255, ${lineOpacity})`; ctx.fillRect(lineDistortionVal, lineY, w - (lineDistortionVal * 2), lineHeight); if (lineHeight > trackingLineMaxHeight * 0.6 || lineOpacity > trackingLineMaxIntensity * 0.7) { intenseGlitchSignalDetected = true; } } if (effectiveBlockDistortionProbability > 0 && Math.random() < effectiveBlockDistortionProbability) { const blockY = Math.random() * h; const blockHeight = Math.random() * (blockDistortionMaxHeight - blockDistortionMinHeight) + blockDistortionMinHeight; const blockDistortionX = (Math.random() - 0.5) * trackingLineDistortion * 1.5; ctx.fillStyle = `rgba(255, 255, 255, ${blockDistortionIntensity * Math.random()})`; ctx.fillRect(blockDistortionX, blockY, w - (blockDistortionX * 2), blockHeight); intenseGlitchSignalDetected = true; } if (intenseGlitchSignalDetected && triggerIntenseTextGlitchOnSignal) { if (intenseGlitchTimeout) clearTimeout(intenseGlitchTimeout); titleElement.classList.add('title-glitch-intense'); intenseGlitchTimeout = setTimeout(() => { if (titleElement) titleElement.classList.remove('title-glitch-intense'); intenseGlitchTimeout = null; }, intenseGlitchDurationMs); } }
            function drawHumBar() { if (!humBarEnabled || h <= 0 || humBarBaseOpacity === 0) return; humBarY += humBarBaseSpeed * 0.1 * masterIntensity; if (humBarY > h + humBarHeight) humBarY = -humBarHeight; ctx.fillStyle = `rgba(128, 128, 128, ${humBarBaseOpacity * masterIntensity})`; ctx.fillRect(0, humBarY, w, humBarHeight); }

            // --- Effect Application Functions ---
            function applyBadTrackingJitter() { if (!badTrackingEnabled || !titleElement || Math.random() > badTrackingBaseProbability * masterIntensity) { if (currentBadTrackingYOffset !== 0) { currentBadTrackingYOffset = 0; updateTitleTransform(); } return; } const jumpAmount = (Math.random() - 0.5) * 0.3 * titleElement.offsetHeight; currentBadTrackingYOffset = jumpAmount; updateTitleTransform(); if (badTrackingJumpTimeout) clearTimeout(badTrackingJumpTimeout); badTrackingJumpTimeout = setTimeout(() => { currentBadTrackingYOffset = 0; updateTitleTransform(); badTrackingJumpTimeout = null; }, Math.random() * 100 + 50); }
            function applyCharSwapGlitch() { if (!charSwapEnabled || !titleElement || Math.random() > charSwapBaseProbability * masterIntensity) { if (titleElement.dataset.swapped === 'true') { titleElement.querySelectorAll('span').forEach((span, index) => { if (originalTextSpans[index] !== undefined) span.textContent = originalTextSpans[index]; }); titleElement.dataset.swapped = 'false'; } return; } const spans = titleElement.querySelectorAll('span'); if (spans.length === 0) return; if (titleElement.dataset.swapped !== 'true') { originalTextSpans = Array.from(spans).map(s => s.textContent); } titleElement.dataset.swapped = 'true'; spans.forEach(span => { let text = span.textContent; let newText = text.split(''); let swappedCount = 0; const maxSwaps = Math.ceil(text.length * charSwapDensity * masterIntensity); for (let i = 0; i < text.length && swappedCount < maxSwaps; i++) { if (Math.random() < 0.5) { const glitchChars = "!@#$%^&*?<>()[]{}/|_-=+;:~`█▓▒░"; const randomChar = glitchChars[Math.floor(Math.random() * glitchChars.length)]; newText[i] = randomChar; swappedCount++; } } span.textContent = newText.join(''); }); }
            function applyTextColorFlash() { if (!textColorFlashEnabled || !titleElement || Math.random() > textColorFlashBaseProbability * masterIntensity) { return; } const randomColors = ["#FF00FF", "#00FFFF", "#FFFF00", "#FF0077", "#00FF77"]; const flashColor = randomColors[Math.floor(Math.random() * randomColors.length)]; const currentColor = rootStyle.getPropertyValue('--title-color').trim(); if (originalTitleColor !== currentColor && !titleElement.dataset.flashing) { originalTitleColor = currentColor; } titleElement.dataset.flashing = "true"; rootStyle.setProperty('--title-color', flashColor); if (flashColor.startsWith('#') && flashColor.length === 7) { const r = parseInt(flashColor.substring(1,3),16), g = parseInt(flashColor.substring(3,5),16), b = parseInt(flashColor.substring(5,7),16); rootStyle.setProperty('--title-glow-color', `rgba(${r},${g},${b},0.7)`); } if (textColorFlashTimeout) clearTimeout(textColorFlashTimeout); textColorFlashTimeout = setTimeout(() => { rootStyle.setProperty('--title-color', originalTitleColor); if (originalTitleColor.startsWith('#') && originalTitleColor.length === 7) { const or = parseInt(originalTitleColor.substring(1,3),16), og = parseInt(originalTitleColor.substring(3,5),16), ob = parseInt(originalTitleColor.substring(5,7),16); rootStyle.setProperty('--title-glow-color', `rgba(${or},${og},${ob},0.6)`); } else { rootStyle.setProperty('--title-glow-color', `rgba(0,255,0,0.6)`);} textColorFlashTimeout = null; titleElement.dataset.flashing = "false"; }, Math.random() * 80 + 40); }
            function applyChannelSwitchBurst() { if (!channelSwitchBurstEnabled || Math.random() > channelSwitchBurstBaseProbability * masterIntensity) { return; } if (channelSwitchBurstTimeout) return; const burstDuration = Math.random() * 200 + 100; const originalScanlineOpacity = rootStyle.getPropertyValue('--scanline-opacity'); rootStyle.setProperty('--scanline-opacity', '1'); const randomNoiseColor = [Math.random(), Math.random(), Math.random()]; drawNoise(0.8 + Math.random() * 0.2, randomNoiseColor); channelSwitchBurstTimeout = setTimeout(() => { drawNoise(); rootStyle.setProperty('--scanline-opacity', originalScanlineOpacity); channelSwitchBurstTimeout = null; }, burstDuration); }

            // --- CONTROL HANDLER FUNCTION DEFINITIONS ---
            function updateMasterIntensity() { masterIntensity = parseFloat(masterIntensityElement.value); masterIntensityValueElement.textContent = `${masterIntensity.toFixed(1)}x`; effectiveNoiseIntensity = baseNoiseIntensity * masterIntensity; effectiveNoiseColorTintIntensity = baseNoiseColorTintIntensity * masterIntensity; effectiveTrackingLineProbability = Math.min(1, baseTrackingLineProbability * masterIntensity); effectiveBlockDistortionProbability = Math.min(1, baseBlockDistortionProbability * masterIntensity); effectiveChromaticAberrationOpacity = Math.min(1, baseChromaticAberrationOpacity * masterIntensity); if (staticIntensityElement) staticIntensityValueElement.textContent = effectiveNoiseIntensity.toFixed(2); if (noiseTintIntensityElement) noiseTintIntensityValueElement.textContent = effectiveNoiseColorTintIntensity.toFixed(2); rootStyle.setProperty('--chromatic-aberration-opacity', effectiveChromaticAberrationOpacity.toFixed(2)); if (chromaticAberrationIntensityElement) chromaticAberrationIntensityValueElement.textContent = effectiveChromaticAberrationOpacity.toFixed(2); }
            function applyColorPalette() { const selectedPaletteKey = colorPaletteElement.value; let palette = colorPalettes[selectedPaletteKey]; if (selectedPaletteKey === 'custom') { updateTextColor(); return; } if (!palette) palette = colorPalettes.matrix_green; originalTitleColor = palette.textColor; textColorElement.value = palette.textColor; rootStyle.setProperty('--title-color', palette.textColor); if (palette.textColor && palette.textColor.startsWith('#') && palette.textColor.length === 7) {const r = parseInt(palette.textColor.substring(1,3),16), g = parseInt(palette.textColor.substring(3,5),16), b = parseInt(palette.textColor.substring(5,7),16); rootStyle.setProperty('--title-glow-color', `rgba(${r},${g},${b},${palette.glowFactor || 0.6})`);} else {rootStyle.setProperty('--title-glow-color', `rgba(128,128,128,0.5)`);} rootStyle.setProperty('--text-shadow-color', palette.shadowColor || 'rgba(0,0,0,0.7)'); }
            function updateText() { if (titleElement) { titleElement.innerHTML = textInputElement.value.split('\n').map(line => `<span>${line.trim() || '&nbsp;'}</span>`).join(''); originalTextSpans = Array.from(titleElement.querySelectorAll('span')).map(s => s.textContent); titleElement.dataset.swapped = 'false'; } }
            function updateFontFamily() { rootStyle.setProperty('--main-font-family', fontFamilyElement.value); }
            function updateFontSize() { const val = fontSizeElement.value; rootStyle.setProperty('--font-size-vw', `${val}vw`); fontSizeValueElement.textContent = `${val}vw`; }
            function updateFontStretch() { const val = fontStretchElement.value; rootStyle.setProperty('--font-stretch', `${val}%`); fontStretchValueElement.textContent = `${val}%`; }
            let currentSkewX = 0; let currentSkewY = 0;
            function updateTitleTransform() { if (titleElement) { let baseTransform = `skewX(${currentSkewX}deg) skewY(${currentSkewY}deg) translateY(${currentBadTrackingYOffset}px)`; titleElement.style.transform = baseTransform; } }
            function updateTextSkewX() { currentSkewX = parseFloat(textSkewXElement.value); textSkewXValueElement.textContent = `${currentSkewX}deg`; updateTitleTransform(); }
            function updateTextSkewY() { currentSkewY = parseFloat(textSkewYElement.value); textSkewYValueElement.textContent = `${currentSkewY}deg`; updateTitleTransform(); }
            function updateTextBloomBlur() { textBloomBlur = parseFloat(textBloomBlurElement.value); rootStyle.setProperty('--text-bloom-blur', `${textBloomBlur}px`); textBloomBlurValueElement.textContent = `${textBloomBlur.toFixed(1)}px`; }
            function updateTextBloomBrightness() { textBloomBrightness = parseFloat(textBloomBrightnessElement.value); rootStyle.setProperty('--text-bloom-brightness', textBloomBrightness); textBloomBrightnessValueElement.textContent = textBloomBrightness.toFixed(2); }
            function updateTextColor() { const color = textColorElement.value; originalTitleColor = color; rootStyle.setProperty('--title-color', color); if (color.startsWith('#') && color.length === 7) { const r = parseInt(color.substring(1,3),16), g = parseInt(color.substring(3,5),16), b = parseInt(color.substring(5,7),16); rootStyle.setProperty('--title-glow-color', `rgba(${r},${g},${b},0.6)`); } else { rootStyle.setProperty('--title-glow-color', `rgba(0,255,0,0.6)`); } if (colorPaletteElement.value !== 'custom') colorPaletteElement.value = 'custom'; }
            function updateShadowOffsetX() { const o = shadowOffsetXElement.value; rootStyle.setProperty('--text-shadow-offset-x', `${o}px`); shadowOffsetXValueElement.textContent = `${o}px`; }
            function updateShadowOffsetY() { const o = shadowOffsetYElement.value; rootStyle.setProperty('--text-shadow-offset-y', `${o}px`); shadowOffsetYValueElement.textContent = `${o}px`; }
            function updateBaseChromaticAberration() { baseChromaticAberrationOpacity = parseFloat(chromaticAberrationIntensityElement.value); effectiveChromaticAberrationOpacity = Math.min(1, baseChromaticAberrationOpacity * masterIntensity); rootStyle.setProperty('--chromatic-aberration-opacity', effectiveChromaticAberrationOpacity.toFixed(2)); chromaticAberrationIntensityValueElement.textContent = baseChromaticAberrationOpacity.toFixed(2); }
            function updateTextPixelation() { rootStyle.setProperty('--text-pixelation', textPixelationToggleElement.checked ? 'pixelated' : 'auto'); }
            function updateEnableBadTracking() { badTrackingEnabled = enableBadTrackingElement.checked; }
            function updateBadTrackingProbability() { badTrackingBaseProbability = parseFloat(badTrackingProbabilityElement.value); badTrackingProbabilityValueElement.textContent = badTrackingBaseProbability.toFixed(3); }
            function updateEnableCharSwap() { charSwapEnabled = enableCharSwapElement.checked; }
            function updateCharSwapProbability() { charSwapBaseProbability = parseFloat(charSwapProbabilityElement.value); charSwapProbabilityValueElement.textContent = charSwapBaseProbability.toFixed(3); }
            function updateCharSwapDensity() { charSwapDensity = parseFloat(charSwapDensityElement.value) / 100; charSwapDensityValueElement.textContent = `${(charSwapDensity * 100).toFixed(0)}%`; }
            function updateEnableTextColorFlash() { textColorFlashEnabled = enableTextColorFlashElement.checked; }
            function updateTextColorFlashProbability() { textColorFlashBaseProbability = parseFloat(textColorFlashProbabilityElement.value); textColorFlashProbabilityValueElement.textContent = textColorFlashBaseProbability.toFixed(3); }
            function updateDisableBeatScale() { beatScaleDisabled = disableBeatScaleToggleElement.checked; updateSimulatedBeatScale(); }
            function updateSimulatedAudioPulse() { simulatedAudioPulseEnabled = simulatedAudioPulseToggleElement.checked; if (simulatedAudioPulseEnabled) { titleElement.classList.add('simulated-audio-pulse'); } else { titleElement.classList.remove('simulated-audio-pulse'); } updateTitleTransform(); }
            function updateSimulatedBeatScale() { const val = simulatedBeatScaleElement.value; if (!beatScaleDisabled) { rootStyle.setProperty('--simulated-beat-true-scale', val); } else { rootStyle.setProperty('--simulated-beat-true-scale', '1'); } simulatedBeatScaleValueElement.textContent = val; }
            function updateSimulatedBeatOpacity() { const val = simulatedBeatOpacityElement.value; rootStyle.setProperty('--simulated-beat-opacity', val); simulatedBeatOpacityValueElement.textContent = val; }
            function updateSimulatedBeatDuration() { const val = simulatedBeatDurationElement.value; rootStyle.setProperty('--simulated-beat-duration', `${val}s`); simulatedBeatDurationValueElement.textContent = `${val}s`; }
            function updateBaseGlitchSpeed() { const s = baseGlitchSpeedElement.value; rootStyle.setProperty('--glitch-base-duration', `${s}s`); baseGlitchSpeedValueElement.textContent = `${s}s`; }
            function updateIntenseGlitchSpeed() { const s = intenseGlitchSpeedElement.value; rootStyle.setProperty('--glitch-intense-duration', `${s}s`); intenseGlitchSpeedValueElement.textContent = `${s}s`; intenseGlitchDurationMs = parseFloat(s) * 1000 * 0.5; }
            function updatePulseSpeed() { const s = pulseSpeedElement.value; rootStyle.setProperty('--pulse-duration', `${s}s`); pulseSpeedValueElement.textContent = `${s}s`; }
            function updateBaseStaticIntensity() { baseNoiseIntensity = parseFloat(staticIntensityElement.value); effectiveNoiseIntensity = baseNoiseIntensity * masterIntensity; staticIntensityValueElement.textContent = baseNoiseIntensity.toFixed(2); }
            function updateBaseNoiseTintIntensity() { baseNoiseColorTintIntensity = parseFloat(noiseTintIntensityElement.value); effectiveNoiseColorTintIntensity = baseNoiseColorTintIntensity * masterIntensity; noiseTintIntensityValueElement.textContent = baseNoiseColorTintIntensity.toFixed(2); }
            function updateVhsEffectType() { const type = vhsEffectTypeElement.value; let tempBaseTrackingProb = 0.09, tempBaseBlockProb = 0.02; switch (type) { case 'none': tempBaseTrackingProb = 0; tempBaseBlockProb = 0; break; case 'subtle': tempBaseTrackingProb = 0.09; tempBaseBlockProb = 0.02; trackingLineMaxHeight = 12; blockDistortionMaxHeight = 30; break; case 'moderate': tempBaseTrackingProb = 0.15; tempBaseBlockProb = 0.05; trackingLineMaxHeight = 20; blockDistortionMaxHeight = 50; break; case 'heavy': tempBaseTrackingProb = 0.25; tempBaseBlockProb = 0.1; trackingLineMaxHeight = 30; blockDistortionMaxHeight = 70; break; } baseTrackingLineProbability = tempBaseTrackingProb; baseBlockDistortionProbability = tempBaseBlockProb; effectiveTrackingLineProbability = Math.min(1, baseTrackingLineProbability * masterIntensity); effectiveBlockDistortionProbability = Math.min(1, baseBlockDistortionProbability * masterIntensity); }
            function updateEnableIntenseTextGlitchOnSignal() { triggerIntenseTextGlitchOnSignal = enableIntenseTextGlitchOnSignalElement.checked; }
            function updateScanlineThickness() { const t = scanlineThicknessElement.value; rootStyle.setProperty('--scanline-thickness', `${t}px`); scanlineThicknessValueElement.textContent = `${t}px`; }
            function updateScanlineOpacity() { const o = scanlineOpacityElement.value; rootStyle.setProperty('--scanline-opacity', o); scanlineOpacityValueElement.textContent = o; }
            function updateCrtScale() { const s = crtScaleElement.value; rootStyle.setProperty('--crt-scale', s); crtScaleValueElement.textContent = parseFloat(s).toFixed(2); }
            function updateCrtLensEffectOpacity() { const o = crtLensEffectOpacityElement.value; rootStyle.setProperty('--crt-lens-effect-opacity', o); crtLensEffectOpacityValueElement.textContent = parseFloat(o).toFixed(2); }
            function updateCrtLensShineOpacity() { const o = crtLensShineOpacityElement.value; rootStyle.setProperty('--crt-lens-shine-opacity', o); crtLensShineOpacityValueElement.textContent = parseFloat(o).toFixed(2); }
            function updateCrtLensEdgeDarkenOpacity() { const o = crtLensEdgeDarkenOpacityElement.value; rootStyle.setProperty('--crt-lens-edge-darken-opacity', o); crtLensEdgeDarkenOpacityValueElement.textContent = parseFloat(o).toFixed(2); }
            function updateEnableHumBar() { humBarEnabled = enableHumBarElement.checked; }
            function updateHumBarOpacity() { humBarBaseOpacity = parseFloat(humBarOpacityElement.value); humBarOpacityValueElement.textContent = humBarBaseOpacity.toFixed(2); }
            function updateHumBarSpeed() { humBarBaseSpeed = parseFloat(humBarSpeedElement.value); humBarSpeedValueElement.textContent = humBarBaseSpeed.toFixed(0); }
            function updateEnableChannelSwitchBurst() { channelSwitchBurstEnabled = enableChannelSwitchBurstElement.checked; }
            function updateChannelSwitchBurstProbability() { channelSwitchBurstBaseProbability = parseFloat(channelSwitchBurstProbabilityElement.value); channelSwitchBurstProbabilityValueElement.textContent = channelSwitchBurstBaseProbability.toFixed(3); }

            // --- Save/Load Settings ---
            const SETTINGS_STORAGE_KEY = 'hyperionVHSSettings_v2';
            const controlIdsToSave = [ 'masterIntensity', 'colorPalette', 'textInput', 'fontFamily', 'fontSize', 'fontStretch', 'textColor', 'textSkewX', 'textSkewY', 'textBloomBlur', 'textBloomBrightness', 'shadowOffsetX', 'shadowOffsetY', 'chromaticAberrationIntensity', 'textPixelationToggle', 'enableBadTracking', 'badTrackingProbability', 'enableCharSwap', 'charSwapProbability', 'charSwapDensity', 'simulatedAudioPulseToggle', 'disableBeatScaleToggle', 'simulatedBeatScale', 'simulatedBeatOpacity', 'simulatedBeatDuration', 'enableTextColorFlash', 'textColorFlashProbability', /*'glitchSliceHeight', REMOVED*/ 'baseGlitchSpeed', 'intenseGlitchSpeed', 'pulseSpeed', 'crtScale', 'crtLensEffectOpacity', 'crtLensShineOpacity', 'crtLensEdgeDarkenOpacity', 'enableHumBar', 'humBarOpacity', 'humBarSpeed', 'enableChannelSwitchBurst', 'channelSwitchBurstProbability', 'enableIntenseTextGlitchOnSignal', 'scanlineThickness', 'staticIntensity', 'noiseTintIntensity', 'vhsEffectType', 'scanlineOpacity' ]; 
            function saveSettings() { const settings = {}; controlIdsToSave.forEach(id => { const element = document.getElementById(id); if (element) { if (element.type === 'checkbox') { settings[id] = element.checked; } else { settings[id] = element.value; } } else { console.warn("Element not found during save:", id); } }); try { localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings)); alert('Settings Saved!'); console.log("Saved settings:", settings); } catch (e) { console.error("Failed to save settings to localStorage:", e); alert('Error saving settings.'); } }
            function loadSettings() { 
                let success = false;
                try { 
                    const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY); 
                    if (savedSettings) { 
                        const settings = JSON.parse(savedSettings); 
                        console.log("Loading settings:", settings); 
                        let requiresMasterIntensityUpdate = false; 
                        const handlerMap = {}; 
                        controls.forEach(c => { if (c.el?.id && typeof c.handler === 'function') { handlerMap[c.el.id] = c.handler; } }); 
                        controlIdsToSave.forEach(id => { 
                            const element = document.getElementById(id); 
                            if (element && settings[id] !== undefined) { 
                                let valueChanged = false; 
                                if (element.type === 'checkbox') { 
                                    if (element.checked !== settings[id]) { element.checked = settings[id]; valueChanged = true; } 
                                } else { 
                                    if (element.value !== settings[id]) { element.value = settings[id]; valueChanged = true; } 
                                } 
                                // IMPORTANT: Always call handler after setting value from storage
                                if (handlerMap[id]) { 
                                     console.log(`Calling handler for loaded setting: ${id}`); 
                                     try { 
                                         handlerMap[id](); 
                                         if (['staticIntensity', 'noiseTintIntensity', 'chromaticAberrationIntensity', 'badTrackingProbability', 'charSwapProbability', 'charSwapDensity', 'textColorFlashProbability', 'vhsEffectType', 'humBarOpacity', 'humBarSpeed', 'channelSwitchBurstProbability'].includes(id)) { requiresMasterIntensityUpdate = true; } 
                                     } catch(e) { console.error(`Error calling handler for ${id} during load:`, e); } 
                                } else { console.warn(`No handler found in map for loaded element: ${id}`); } 
                            } else if (settings[id] === undefined && element) { /* Setting missing */ } 
                            else if (!element && settings[id] !== undefined) { console.warn("Element not found during load:", id); } 
                        }); 
                        if (requiresMasterIntensityUpdate && masterIntensityElement && typeof updateMasterIntensity === 'function') { console.log("Re-applying master intensity after loading dependent base values."); updateMasterIntensity(); } 
                        console.log("Settings Loaded processing complete."); 
                        success = true; 
                    } else { console.log('No saved settings found.'); } 
                } catch (e) { console.error("Failed to load settings from localStorage:", e); alert('Error loading settings.'); }
                return success; 
            }

             // --- Generate Standalone HTML ---
             function generateStandaloneHTML() {
                 console.log("Generating standalone HTML...");
                 const currentTextContent = textInputElement.value;
                 const textLines = currentTextContent.split('\n');
                 const titleSpansHTML = textLines.map(line => { const trimmedLine = line.trim(); const safeLine = trimmedLine.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); return `<span>${safeLine || '&nbsp;'}</span>`; }).join('');
                 const computedRootStyle = getComputedStyle(document.documentElement);
                 const cssVariables = {};
                 const cssVarNames = [ '--main-font-family', '--font-size-vw', '--font-stretch', '--title-color', '--text-skew-x', '--text-skew-y', '--text-bloom-blur', '--text-bloom-brightness', '--title-glow-color', '--text-shadow-offset-x', '--text-shadow-offset-y', '--text-shadow-blur', '--text-shadow-color', '--chromatic-aberration-opacity', '--pulse-duration', '--glitch-base-duration', '--glitch-intense-duration', '--crt-scale', '--crt-perspective', '--crt-lens-effect-opacity', '--crt-lens-shine-opacity', '--crt-lens-edge-darken-opacity', '--scanline-opacity', '--scanline-thickness', '--scanline-color1', '--scanline-color2', '--text-pixelation', '--simulated-beat-scale', '--simulated-beat-true-scale', '--simulated-beat-opacity', '--simulated-beat-duration' ]; 
                 cssVarNames.forEach(varName => { let value = computedRootStyle.getPropertyValue(varName).trim(); if (typeof value === 'string') { value = value.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;'); if (varName === '--main-font-family' && value) { value = value.replace(/"/g, "'"); } } cssVariables[varName] = value; });
                 const currentMasterIntensityValue = parseFloat(masterIntensityElement.value) || 1.0; 
                 const jsParams = { effectiveNoiseIntensity: parseFloat(effectiveNoiseIntensity.toFixed(4)) || 0, effectiveNoiseColorTintIntensity: parseFloat(effectiveNoiseColorTintIntensity.toFixed(4)) || 0, effectiveTrackingLineProbability: parseFloat(effectiveTrackingLineProbability.toFixed(4)) || 0, effectiveBlockDistortionProbability: parseFloat(effectiveBlockDistortionProbability.toFixed(4)) || 0, trackingLineMaxHeight: parseInt(trackingLineMaxHeight) || 12, trackingLineMinHeight: parseInt(trackingLineMinHeight) || 1, trackingLineDistortion: parseInt(trackingLineDistortion) || 20, trackingLineMinIntensity: parseFloat(trackingLineMinIntensity.toFixed(2)) || 0.1, trackingLineMaxIntensity: parseFloat(trackingLineMaxIntensity.toFixed(2)) || 0.8, blockDistortionMaxHeight: parseInt(blockDistortionMaxHeight) || 30, blockDistortionMinHeight: parseInt(blockDistortionMinHeight) || 5, blockDistortionIntensity: parseFloat(blockDistortionIntensity.toFixed(2)) || 0.6, badTrackingEnabled: !!badTrackingEnabled, badTrackingBaseProbability: parseFloat(badTrackingBaseProbability.toFixed(4)) || 0, charSwapEnabled: !!charSwapEnabled, charSwapBaseProbability: parseFloat(charSwapBaseProbability.toFixed(4)) || 0, charSwapDensity: parseFloat(charSwapDensity.toFixed(4)) || 0, textColorFlashEnabled: !!textColorFlashEnabled, textColorFlashBaseProbability: parseFloat(textColorFlashBaseProbability.toFixed(4)) || 0, humBarEnabled: !!humBarEnabled, humBarBaseOpacity: parseFloat(humBarBaseOpacity.toFixed(4)) || 0, humBarBaseSpeed: parseFloat(humBarBaseSpeed.toFixed(4)) || 0, channelSwitchBurstEnabled: !!channelSwitchBurstEnabled, channelSwitchBurstBaseProbability: parseFloat(channelSwitchBurstBaseProbability.toFixed(4)) || 0, triggerIntenseTextGlitchOnSignal: !!triggerIntenseTextGlitchOnSignal, intenseGlitchDurationMs: parseInt(intenseGlitchDurationMs) || 150, masterIntensity: currentMasterIntensityValue };
                 const titleClasses = titleElement ? titleElement.classList.toString() : '';
                 const escapedJsParamsString = JSON.stringify(jsParams).replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$\{/g, '\\${'); // Escape for template literal

                 const htmlTemplate = `<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>VHS Glitch Output</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&family=Orbitron:wght@400;700&family=Audiowide&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
:root { ${Object.entries(cssVariables).map(([key, value]) => `    ${key}: ${value};`).join('\n')} }
body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; position: relative; font-family: var(--main-font-family); color: #eee; }
#simulationCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; display: block; }
.content-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; overflow: hidden; perspective: var(--crt-perspective); }
.content { z-index: 2; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; pointer-events: none; transform-origin: center center; transform: scale(var(--crt-scale)); transition: transform 0.1s ease-out; }
.content-wrapper::before { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: radial-gradient(ellipse at center, rgba(255,255,255,var(--crt-lens-shine-opacity)) 0%, rgba(255,255,255,var(--crt-lens-shine-opacity)) 30%, rgba(0,0,0, var(--crt-lens-edge-darken-opacity)) 70%, rgba(0,0,0, var(--crt-lens-edge-darken-opacity)) 100% ); z-index: 3; pointer-events: none; border-radius: 50%; opacity: var(--crt-lens-effect-opacity); mix-blend-mode: overlay; transition: opacity 0.2s; }
.title { pointer-events: auto; display: block; text-align: center; font-family: var(--main-font-family); font-size: clamp(30px, var(--font-size-vw), 200px); font-stretch: var(--font-stretch); font-weight: bold; color: var(--title-color); text-transform: uppercase; text-shadow: var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color), 0 0 8px var(--title-glow-color), 0 0 15px color-mix(in srgb, var(--title-glow-color) 70%, transparent), 1px 1px 1px rgba(0, 255, 255, var(--chromatic-aberration-opacity)), -1px -1px 1px rgba(255, 0, 255, var(--chromatic-aberration-opacity)); animation: pulse var(--pulse-duration) ease-in-out 0s infinite alternate, glitch-base var(--glitch-base-duration) steps(6, end) 0s infinite; transform-origin: center center; user-select: none; transform: skewX(var(--text-skew-x)) skewY(var(--text-skew-y)); transition: transform 0.05s linear, color 0.3s, text-shadow 0.3s, filter 0.2s; image-rendering: var(--text-pixelation); filter: blur(var(--text-bloom-blur)) brightness(var(--text-bloom-brightness)); }
${titleClasses.includes('simulated-audio-pulse') ? `.title.simulated-audio-pulse { animation: simulated-pulse-beat var(--simulated-beat-duration) ease-in-out infinite alternate; }` : ''}
@keyframes simulated-pulse-beat { from { opacity: 1; } to { transform: scale(var(--simulated-beat-true-scale)); opacity: var(--simulated-beat-opacity); } }
.title span { display: block; line-height: 0.9; margin-bottom: -0.1em; }
body::after { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(var(--scanline-color1) 50%, var(--scanline-color2) 50%); background-size: 100% var(--scanline-thickness); z-index: 1; pointer-events: none; animation: scanline-flicker 0.07s infinite alternate; opacity: var(--scanline-opacity); }
@keyframes scanline-flicker { from { filter: brightness(0.95); } to { filter: brightness(1.05); } }
@keyframes glitch-base { 0%, 100% { transform: translate(0, 0); text-shadow: 1px 1px 0 rgba(0, 255, 255, 0.5), -1px -1px 0 rgba(255, 0, 255, 0.5), var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 20% { transform: translate(-1px, 1px); } 40% { transform: translate(1px, -1px); text-shadow: -1px 1px 0 rgba(0, 255, 255, 0.5), 1px -1px 0 rgba(255, 0, 255, 0.5), var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 60% { transform: translate(0, 0); text-shadow: 1px 1px 0 rgba(0, 255, 255, 0.5), -1px -1px 0 rgba(255, 0, 255, 0.5), var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 80% { transform: translate(1px, 1px); } }
${jsParams.triggerIntenseTextGlitchOnSignal || titleClasses.includes('title-glitch-intense') ? `.title-glitch-intense { animation: pulse var(--pulse-duration) ease-in-out 0s infinite alternate, glitch-intense var(--glitch-intense-duration) steps(4, end) 0s infinite; }` : '.title-glitch-intense {}'}
@keyframes glitch-intense { 0% { transform: translate(6px, -4px) skewX(calc(-12deg * ${jsParams.masterIntensity} * 0.7)) skewY(calc(1deg * ${jsParams.masterIntensity})); text-shadow: 6px 3px 0 #00ffff, -6px -3px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 25% { transform: translate(-5px, 3px) skewX(calc(20deg * ${jsParams.masterIntensity})) skewY(calc(-1.5deg * ${jsParams.masterIntensity})); text-shadow: -4px 4px 0 #00ffff, 4px -4px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 50% { transform: translate(4px, -2px) skewX(calc(-15deg * ${jsParams.masterIntensity})) skewY(calc(2deg * ${jsParams.masterIntensity})); text-shadow: 5px -3px 0 #00ffff, -5px 3px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 75% { transform: translate(-3px, 5px) skewX(calc(25deg * ${jsParams.masterIntensity} * 0.8)) skewY(calc(-2.5deg * ${jsParams.masterIntensity})); text-shadow: -3px -3px 0 #00ffff, 3px 3px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } 100% { transform: translate(5px, -3px) skewX(calc(-18deg * ${jsParams.masterIntensity})) skewY(calc(1.5deg * ${jsParams.masterIntensity})); text-shadow: 4px 2px 0 #00ffff, -4px -2px 0 #ff00ff, var(--text-shadow-offset-x) var(--text-shadow-offset-y) var(--text-shadow-blur) var(--text-shadow-color); } }
@keyframes pulse { 0% { opacity: 1; } 50% { transform: scale(1.04); opacity: 0.85; } 100% { opacity: 1; } }
</style></head>
<body>
<canvas id="simulationCanvas"></canvas><div class="content-wrapper"><div class="content"><h1 class="title ${titleClasses}" id="mainTitle">${titleSpansHTML}</h1></div></div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('simulationCanvas'); const titleElement = document.getElementById('mainTitle'); const ctx = canvas.getContext('2d', { alpha: false }); const rootStyle = document.documentElement.style; 
    const params = JSON.parse(\`${escapedJsParamsString}\`); /* Use escaped JSON string */
    const masterIntensity = params.masterIntensity; let w, h, noiseImageData; let badTrackingJumpTimeout = null; let currentBadTrackingYOffset = 0; let charSwapOriginalText = {}; let textColorFlashTimeout = null; const originalColor = "${cssVariables['--title-color']}"; const originalGlow = "${cssVariables['--title-glow-color']}"; let channelSwitchBurstTimeout = null; let intenseGlitchTimeout = null; let humBarY = 0; const humBarHeight = 50; 
    function resizeCanvas() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; if (w > 0 && h > 0) { noiseImageData = ctx.createImageData(w, h); } }
    function drawNoise(overrideIntensity, overrideColor) { if (!noiseImageData || (overrideIntensity === undefined && params.effectiveNoiseIntensity === 0)) return; const intensityToUse = overrideIntensity !== undefined ? overrideIntensity : params.effectiveNoiseIntensity; const pixels = noiseImageData.data; const len = pixels.length; for (let i = 0; i < len; i += 4) { const noiseValue = Math.random() * 255 * intensityToUse; if (overrideColor) { pixels[i] = Math.max(0, Math.min(255, noiseValue * overrideColor[0])); pixels[i + 1] = Math.max(0, Math.min(255, noiseValue * overrideColor[1])); pixels[i + 2] = Math.max(0, Math.min(255, noiseValue * overrideColor[2])); } else { const rTint = (Math.random() - 0.5) * 255 * params.effectiveNoiseColorTintIntensity; const bTint = (Math.random() - 0.5) * 255 * params.effectiveNoiseColorTintIntensity; pixels[i] = Math.max(0, Math.min(255, noiseValue + rTint)); pixels[i + 1] = Math.max(0, Math.min(255, noiseValue)); pixels[i + 2] = Math.max(0, Math.min(255, noiseValue + bTint)); } pixels[i + 3] = 255; } ctx.putImageData(noiseImageData, 0, 0); }
    function drawTrackingLines() { if (!titleElement) return; let intenseGlitchSignalDetected = false; if (params.effectiveTrackingLineProbability > 0 && Math.random() < params.effectiveTrackingLineProbability) { const lineY = Math.random() * h; const lineHeight = Math.random() * (params.trackingLineMaxHeight - params.trackingLineMinHeight) + params.trackingLineMinHeight; const lineOpacity = Math.random() * (params.trackingLineMaxIntensity - params.trackingLineMinIntensity) + params.trackingLineMinIntensity; const lineDistortionVal = (Math.random() - 0.5) * 2 * params.trackingLineDistortion; ctx.fillStyle = \`rgba(255, 255, 255, \${lineOpacity})\`; ctx.fillRect(lineDistortionVal, lineY, w - (lineDistortionVal * 2), lineHeight); if (lineHeight > params.trackingLineMaxHeight * 0.6 || lineOpacity > params.trackingLineMaxIntensity * 0.7) { intenseGlitchSignalDetected = true; } } if (params.effectiveBlockDistortionProbability > 0 && Math.random() < params.effectiveBlockDistortionProbability) { const blockY = Math.random() * h; const blockHeight = Math.random() * (params.blockDistortionMaxHeight - params.blockDistortionMinHeight) + params.blockDistortionMinHeight; const blockDistortionX = (Math.random() - 0.5) * params.trackingLineDistortion * 1.5; ctx.fillStyle = \`rgba(255, 255, 255, \${params.blockDistortionIntensity * Math.random()})\`; ctx.fillRect(blockDistortionX, blockY, w - (blockDistortionX * 2), blockHeight); intenseGlitchSignalDetected = true; } if (intenseGlitchSignalDetected && params.triggerIntenseTextGlitchOnSignal) { if (intenseGlitchTimeout) clearTimeout(intenseGlitchTimeout); titleElement.classList.add('title-glitch-intense'); intenseGlitchTimeout = setTimeout(() => { if (titleElement) titleElement.classList.remove('title-glitch-intense'); intenseGlitchTimeout = null; }, params.intenseGlitchDurationMs); } }
    function drawHumBar() { if (!params.humBarEnabled || h <= 0 || params.humBarBaseOpacity === 0) return; humBarY += params.humBarBaseSpeed * 0.1 * masterIntensity; if (humBarY > h + humBarHeight) humBarY = -humBarHeight; ctx.fillStyle = \`rgba(128, 128, 128, \${params.humBarBaseOpacity * masterIntensity})\`; ctx.fillRect(0, humBarY, w, humBarHeight); }
    function applyBadTrackingJitter() { if (!params.badTrackingEnabled || !titleElement || Math.random() > params.badTrackingBaseProbability * masterIntensity) { if (currentBadTrackingYOffset !== 0) { currentBadTrackingYOffset = 0; updateTitleTransform(); } return; } const jumpAmount = (Math.random() - 0.5) * 0.3 * titleElement.offsetHeight; currentBadTrackingYOffset = jumpAmount; updateTitleTransform(); if (badTrackingJumpTimeout) clearTimeout(badTrackingJumpTimeout); badTrackingJumpTimeout = setTimeout(() => { currentBadTrackingYOffset = 0; updateTitleTransform(); badTrackingJumpTimeout = null; }, Math.random() * 100 + 50); }
    function applyCharSwapGlitch() { if (!params.charSwapEnabled || !titleElement || Math.random() > params.charSwapBaseProbability * masterIntensity) { if (titleElement.dataset.swapped === 'true') { titleElement.querySelectorAll('span').forEach((span, index) => { if (charSwapOriginalText[index] !== undefined) span.textContent = charSwapOriginalText[index]; }); titleElement.dataset.swapped = 'false'; } return; } const spans = titleElement.querySelectorAll('span'); if (spans.length === 0) return; if (titleElement.dataset.swapped !== 'true') { spans.forEach((s, i) => charSwapOriginalText[i] = s.textContent ); } titleElement.dataset.swapped = 'true'; spans.forEach(span => { let text = span.textContent; let newText = text.split(''); let swappedCount = 0; const maxSwaps = Math.ceil(text.length * params.charSwapDensity * masterIntensity); for (let i = 0; i < text.length && swappedCount < maxSwaps; i++) { if (Math.random() < 0.5) { const glitchChars = "!@#$%^&*?<>()[]{}/|_-=+;:~\\\`█▓▒░"; const randomChar = glitchChars[Math.floor(Math.random() * glitchChars.length)]; newText[i] = randomChar; swappedCount++; } } span.textContent = newText.join(''); }); }
    function applyTextColorFlash() { if (!params.textColorFlashEnabled || !titleElement || Math.random() > params.textColorFlashBaseProbability * masterIntensity) { return; } const randomColors = ["#FF00FF", "#00FFFF", "#FFFF00", "#FF0077", "#00FF77"]; const flashColor = randomColors[Math.floor(Math.random() * randomColors.length)]; titleElement.dataset.flashing = "true"; rootStyle.setProperty('--title-color', flashColor); if (flashColor.startsWith('#') && flashColor.length === 7) { const r = parseInt(flashColor.substring(1,3),16), g = parseInt(flashColor.substring(3,5),16), b = parseInt(flashColor.substring(5,7),16); rootStyle.setProperty('--title-glow-color', \`rgba(\${r},\${g},\${b},0.7)\`); } if (textColorFlashTimeout) clearTimeout(textColorFlashTimeout); textColorFlashTimeout = setTimeout(() => { rootStyle.setProperty('--title-color', originalColor); rootStyle.setProperty('--title-glow-color', originalGlow); textColorFlashTimeout = null; titleElement.dataset.flashing = "false"; }, Math.random() * 80 + 40); }
    function applyChannelSwitchBurst() { if (!params.channelSwitchBurstEnabled || Math.random() > params.channelSwitchBurstBaseProbability * masterIntensity) { return; } if (channelSwitchBurstTimeout) return; const burstDuration = Math.random() * 200 + 100; const currentScanlineOpacity = getComputedStyle(document.documentElement).getPropertyValue('--scanline-opacity'); rootStyle.setProperty('--scanline-opacity', '1'); const randomNoiseColor = [Math.random(), Math.random(), Math.random()]; drawNoise(0.8 + Math.random() * 0.2, randomNoiseColor); channelSwitchBurstTimeout = setTimeout(() => { drawNoise(); rootStyle.setProperty('--scanline-opacity', currentScanlineOpacity); channelSwitchBurstTimeout = null; }, burstDuration); }
    function updateTitleTransform() { if (titleElement) { titleElement.style.transform = \`translateY(\${currentBadTrackingYOffset}px)\`; } }
    function animate() { applyBadTrackingJitter(); applyCharSwapGlitch(); applyTextColorFlash(); applyChannelSwitchBurst(); if (w > 0 && h > 0 && !channelSwitchBurstTimeout) { drawNoise(); drawHumBar(); drawTrackingLines(); } else if (w > 0 && h > 0 && channelSwitchBurstTimeout) {} requestAnimationFrame(animate); }
    window.addEventListener('resize', resizeCanvas); resizeCanvas(); 
    if (titleElement) { titleElement.querySelectorAll('span').forEach((span, index) => { charSwapOriginalText[index] = span.textContent; }); }
    updateTitleTransform(); animate(); 
});
<\/script> 
</body>
</html>`;

                 // 6. Trigger Download
                 try {
                     const blob = new Blob([htmlTemplate], { type: 'text/html' });
                     const link = document.createElement('a');
                     link.href = URL.createObjectURL(blob);
                     const suggestedFilename = textLines[0]?.trim().toLowerCase().replace(/[^a-z0-9]+/g, '_').substring(0, 20) || 'vhs_output'; 
                     link.download = `${suggestedFilename}.html`;
                     document.body.appendChild(link);
                     link.click();
                     document.body.removeChild(link);
                     URL.revokeObjectURL(link.href);
                     console.log("Standalone HTML generation successful.");
                 } catch (e) {
                     console.error("Error generating or downloading standalone HTML:", e);
                     alert("Failed to generate standalone HTML file.");
                 }
             }


            // --- Panel Toggle ---
            const panelVisibleKey = 'vhssimControlsVisible'; function setPanelVisibility(visible) { if (visible) { controlsPanel.classList.remove('hidden'); toggleControlsBtn.textContent = 'Hide Controls'; const panelRect = controlsPanel.getBoundingClientRect(); toggleControlsBtn.style.left = `${Math.min(window.innerWidth - toggleControlsBtn.offsetWidth - 10, panelRect.right + 10)}px`; } else { controlsPanel.classList.add('hidden'); toggleControlsBtn.textContent = 'Show Controls'; toggleControlsBtn.style.left = '10px'; } try { localStorage.setItem(panelVisibleKey, visible); } catch (e) { console.warn("LS error:", e); } }
            if (toggleControlsBtn && controlsPanel) { toggleControlsBtn.addEventListener('click', () => { setPanelVisibility(controlsPanel.classList.contains('hidden')); }); let initialVisibility = true; try { const storedVisibility = localStorage.getItem(panelVisibleKey); if (storedVisibility !== null) { initialVisibility = storedVisibility === 'true'; } } catch (e) { console.warn("LS error:", e); } setPanelVisibility(initialVisibility); }

            // --- Event Listeners & Initialization ---
            const controls = [ { el: masterIntensityElement, event: 'input', handler: updateMasterIntensity }, { el: colorPaletteElement, event: 'change', handler: applyColorPalette }, { el: textInputElement, event: 'input', handler: updateText }, { el: fontFamilyElement, event: 'change', handler: updateFontFamily }, { el: fontSizeElement, event: 'input', handler: updateFontSize }, { el: fontStretchElement, event: 'input', handler: updateFontStretch }, { el: textColorElement, event: 'input', handler: updateTextColor }, { el: textSkewXElement, event: 'input', handler: updateTextSkewX }, { el: textSkewYElement, event: 'input', handler: updateTextSkewY }, { el: textBloomBlurElement, event: 'input', handler: updateTextBloomBlur }, { el: textBloomBrightnessElement, event: 'input', handler: updateTextBloomBrightness }, { el: shadowOffsetXElement, event: 'input', handler: updateShadowOffsetX }, { el: shadowOffsetYElement, event: 'input', handler: updateShadowOffsetY }, { el: chromaticAberrationIntensityElement, event: 'input', handler: updateBaseChromaticAberration }, { el: textPixelationToggleElement, event: 'change', handler: updateTextPixelation }, { el: enableBadTrackingElement, event: 'change', handler: updateEnableBadTracking }, { el: badTrackingProbabilityElement, event: 'input', handler: updateBadTrackingProbability }, { el: enableCharSwapElement, event: 'change', handler: updateEnableCharSwap }, { el: charSwapProbabilityElement, event: 'input', handler: updateCharSwapProbability }, { el: charSwapDensityElement, event: 'input', handler: updateCharSwapDensity }, { el: enableTextColorFlashElement, event: 'change', handler: updateEnableTextColorFlash }, { el: textColorFlashProbabilityElement, event: 'input', handler: updateTextColorFlashProbability }, { el: simulatedAudioPulseToggleElement, event: 'change', handler: updateSimulatedAudioPulse }, { el: disableBeatScaleToggleElement, event: 'change', handler: updateDisableBeatScale }, { el: simulatedBeatScaleElement, event: 'input', handler: updateSimulatedBeatScale }, { el: simulatedBeatOpacityElement, event: 'input', handler: updateSimulatedBeatOpacity }, { el: simulatedBeatDurationElement, event: 'input', handler: updateSimulatedBeatDuration }, /* REMOVED SLICE HEIGHT */ { el: baseGlitchSpeedElement, event: 'input', handler: updateBaseGlitchSpeed }, { el: intenseGlitchSpeedElement, event: 'input', handler: updateIntenseGlitchSpeed }, { el: pulseSpeedElement, event: 'input', handler: updatePulseSpeed }, { el: crtScaleElement, event: 'input', handler: updateCrtScale }, { el: crtLensEffectOpacityElement, event: 'input', handler: updateCrtLensEffectOpacity }, { el: crtLensShineOpacityElement, event: 'input', handler: updateCrtLensShineOpacity }, { el: crtLensEdgeDarkenOpacityElement, event: 'input', handler: updateCrtLensEdgeDarkenOpacity }, { el: enableHumBarElement, event: 'change', handler: updateEnableHumBar }, { el: humBarOpacityElement, event: 'input', handler: updateHumBarOpacity }, { el: humBarSpeedElement, event: 'input', handler: updateHumBarSpeed }, { el: enableChannelSwitchBurstElement, event: 'change', handler: updateEnableChannelSwitchBurst }, { el: channelSwitchBurstProbabilityElement, event: 'input', handler: updateChannelSwitchBurstProbability }, { el: enableIntenseTextGlitchOnSignalElement, event: 'change', handler: updateEnableIntenseTextGlitchOnSignal }, { el: scanlineThicknessElement, event: 'input', handler: updateScanlineThickness }, { el: staticIntensityElement, event: 'input', handler: updateBaseStaticIntensity }, { el: noiseTintIntensityElement, event: 'input', handler: updateBaseNoiseTintIntensity }, { el: vhsEffectTypeElement, event: 'change', handler: updateVhsEffectType }, { el: scanlineOpacityElement, event: 'input', handler: updateScanlineOpacity } ];

            // Simplified initialization
            function initializeControls() { 
                console.log("Initializing controls (Setting initial UI values)...");
                controls.forEach(c => {
                    if (c.el) {
                        const displayEl = document.getElementById(c.el.id + "Value");
                        if(displayEl) { 
                             try { 
                                 if (c.el.type === 'range' || c.el.type === 'number') {
                                     let unit = '', precision = 1;
                                     if (c.el.id.includes('Speed') || c.el.id.includes('Duration')) unit = 's';
                                     else if (c.el.id.includes('Size')) unit = 'vw';
                                     else if (c.el.id.includes('Skew') || c.el.id.includes('Blur')) unit = 'deg';
                                     else if (c.el.id.includes('Offset') || c.el.id.includes('Thickness')) unit = 'px';
                                     else if (c.el.id.includes('Density')) unit = '%';
                                     else if (c.el.id.includes('Intensity') || c.el.id === 'masterIntensity') unit = 'x';
                                     const step = parseFloat(c.el.step);
                                     if (step > 0 && step < 1) { precision = step.toString().split('.')[1]?.length || 1; } 
                                     else if (step === 1 && (c.el.id.includes('Brightness') || c.el.id.includes('Scale') || c.el.id.includes('Opacity'))) { precision = 2; } 
                                     else { precision = 0; }
                                     if(c.el.id === 'charSwapDensity') { displayEl.textContent = `${c.el.value}%`; } 
                                     else if (unit === 'x' || c.el.id.includes('Brightness') || c.el.id.includes('Scale') || c.el.id.includes('Opacity') || c.el.id.includes('Probability')) { displayEl.textContent = parseFloat(c.el.value).toFixed(precision); if(unit === 'x') displayEl.textContent += 'x'; } 
                                     else { displayEl.textContent = c.el.value + unit; }
                                } 
                             } catch (err) { console.error("Error updating display for:", c.el.id, err); }
                        }
                    }
                });
                 if (textColorElement) originalTitleColor = textColorElement.value;
                console.log("Initial UI values set.");
            }

            // Function to apply current state from UI elements
            function applyCurrentState() {
                 console.log("Applying current state to visuals and JS variables...");
                 controls.forEach(c => { 
                    if (c.el && typeof c.handler === 'function') {
                        try { c.handler(); } 
                        catch(e){ console.error("Error applying state for:", c.el ? c.el.id : 'unknown element', "Handler:", c.handler.name, e); }
                    }
                 });
                if (masterIntensityElement && typeof updateMasterIntensity === 'function') {
                    try { updateMasterIntensity(); } 
                    catch(e) { console.error("Error applying master intensity",e); }
                }
                 console.log("Current state applied.");
            }

            // Attach event listeners
            controls.forEach(c => { if (c.el && typeof c.handler === 'function') { c.el.addEventListener(c.event, c.handler); } });
            if (saveSettingsBtn) saveSettingsBtn.addEventListener('click', saveSettings);
            if (loadSettingsBtn) loadSettingsBtn.addEventListener('click', () => { loadSettings(); }); // Keep explicit listener
            if (saveStandaloneBtn) saveStandaloneBtn.addEventListener('click', generateStandaloneHTML); 
            
            // Run initial setup for defaults
            initializeControls(); 

            // Attempt to load settings from localStorage
            let loadedSuccessfully = false;
            try {
                const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
                if (savedSettings) {
                     console.log("Found saved settings on load, attempting to apply...");
                     loadedSuccessfully = loadSettings(); 
                     if (!loadedSuccessfully) { console.warn("Loading settings failed, applying defaults instead."); }
                } else { console.log("No saved settings found."); }
            } catch (e) { console.error("Error accessing localStorage on initial load:", e); }
            
            // If settings were NOT successfully loaded, apply the default HTML values
            if (!loadedSuccessfully) {
                console.log("Applying default settings from HTML...");
                applyCurrentState();
            }

            // --- Animation Loop ---
            function animate() {
                applyBadTrackingJitter();
                applyCharSwapGlitch(); 
                applyTextColorFlash(); 
                applyChannelSwitchBurst(); 
                if (w > 0 && h > 0 && !channelSwitchBurstTimeout) { drawNoise(); drawHumBar(); drawTrackingLines(); } 
                else if (w > 0 && h > 0 && channelSwitchBurstTimeout) { /* Burst handles drawing */ }
                requestAnimationFrame(animate);
            }
            
            resizeCanvas(); 
            animate(); 
        });
        // --- END OF EMBEDDED JAVASCRIPT ---
    </script>

</body>
</html>